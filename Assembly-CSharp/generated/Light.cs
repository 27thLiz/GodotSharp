/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace GodotEngine {

public class Light : VisualInstance {
  public static readonly int PARAM_RADIUS = 2;
  public static readonly int PARAM_ENERGY = 3;
  public static readonly int PARAM_ATTENUATION = 4;
  public static readonly int PARAM_SPOT_ANGLE = 1;
  public static readonly int PARAM_SPOT_ATTENUATION = 0;
  public static readonly int PARAM_SHADOW_DARKENING = 5;
  public static readonly int PARAM_SHADOW_Z_OFFSET = 6;
  public static readonly int COLOR_DIFFUSE = 0;
  public static readonly int COLOR_SPECULAR = 1;
  public static readonly int BAKE_MODE_DISABLED = 0;
  public static readonly int BAKE_MODE_INDIRECT = 1;
  public static readonly int BAKE_MODE_INDIRECT_AND_SHADOWS = 2;
  public static readonly int BAKE_MODE_FULL = 3;

  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  
  internal Light(global::System.IntPtr cPtr, bool cMemoryOwn) : base(GodotEnginePINVOKE.Light_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }  
  
  protected Light(bool cMemoryOwn) : base(cMemoryOwn) {}
  
  new internal void internal_init(global::System.IntPtr cPtr) {
    base.internal_init(GodotEnginePINVOKE.Light_SWIGUpcast(cPtr));
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }
  
  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Light obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          throw new global::System.MethodAccessException("C++ destructor does not have public access");
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

  internal Light() {}


  public void set_parameter(int variable, float value) {
    GodotEnginePINVOKE.Light_set_parameter(swigCPtr, variable, value);
  }

  public float get_parameter(int variable) {
    float ret = GodotEnginePINVOKE.Light_get_parameter(swigCPtr, variable);
    return ret;
  }

  public void set_color(int color, SWIGTYPE_p_Color value) {
    GodotEnginePINVOKE.Light_set_color(swigCPtr, color, SWIGTYPE_p_Color.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Color get_color(int color) {
    SWIGTYPE_p_Color ret = new SWIGTYPE_p_Color(GodotEnginePINVOKE.Light_get_color(swigCPtr, color), true);
    return ret;
  }

  public void set_project_shadows(bool enable) {
    GodotEnginePINVOKE.Light_set_project_shadows(swigCPtr, enable);
  }

  public bool has_project_shadows() {
    bool ret = GodotEnginePINVOKE.Light_has_project_shadows(swigCPtr);
    return ret;
  }

  public void set_projector(SWIGTYPE_p_RefT_Texture_t projector) {
    GodotEnginePINVOKE.Light_set_projector(swigCPtr, SWIGTYPE_p_RefT_Texture_t.getCPtr(projector));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_RefT_Texture_t get_projector() {
    SWIGTYPE_p_RefT_Texture_t ret = new SWIGTYPE_p_RefT_Texture_t(GodotEnginePINVOKE.Light_get_projector(swigCPtr), true);
    return ret;
  }

  public void set_operator(int operator_) {
    GodotEnginePINVOKE.Light_set_operator(swigCPtr, operator_);
  }

  public int get_operator() {
    int ret = GodotEnginePINVOKE.Light_get_operator(swigCPtr);
    return ret;
  }

  public void set_bake_mode(int bake_mode) {
    GodotEnginePINVOKE.Light_set_bake_mode(swigCPtr, bake_mode);
  }

  public int get_bake_mode() {
    int ret = GodotEnginePINVOKE.Light_get_bake_mode(swigCPtr);
    return ret;
  }

  public void set_enabled(bool enabled) {
    GodotEnginePINVOKE.Light_set_enabled(swigCPtr, enabled);
  }

  public bool is_enabled() {
    bool ret = GodotEnginePINVOKE.Light_is_enabled(swigCPtr);
    return ret;
  }

  public void set_editor_only(bool editor_only) {
    GodotEnginePINVOKE.Light_set_editor_only(swigCPtr, editor_only);
  }

  public bool is_editor_only() {
    bool ret = GodotEnginePINVOKE.Light_is_editor_only(swigCPtr);
    return ret;
  }

}

}
