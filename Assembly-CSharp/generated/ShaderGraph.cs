/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.2
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

namespace GodotEngine {

public class ShaderGraph : Shader {
  public static readonly int NODE_INPUT = 0;
  public static readonly int NODE_SCALAR_CONST = 1;
  public static readonly int NODE_VEC_CONST = 2;
  public static readonly int NODE_RGB_CONST = 3;
  public static readonly int NODE_XFORM_CONST = 4;
  public static readonly int NODE_TIME = 5;
  public static readonly int NODE_SCREEN_TEX = 6;
  public static readonly int NODE_SCALAR_OP = 7;
  public static readonly int NODE_VEC_OP = 8;
  public static readonly int NODE_VEC_SCALAR_OP = 9;
  public static readonly int NODE_RGB_OP = 10;
  public static readonly int NODE_XFORM_MULT = 11;
  public static readonly int NODE_XFORM_VEC_MULT = 12;
  public static readonly int NODE_XFORM_VEC_INV_MULT = 13;
  public static readonly int NODE_SCALAR_FUNC = 14;
  public static readonly int NODE_VEC_FUNC = 15;
  public static readonly int NODE_VEC_LEN = 16;
  public static readonly int NODE_DOT_PROD = 17;
  public static readonly int NODE_VEC_TO_SCALAR = 18;
  public static readonly int NODE_SCALAR_TO_VEC = 19;
  public static readonly int NODE_VEC_TO_XFORM = 21;
  public static readonly int NODE_XFORM_TO_VEC = 20;
  public static readonly int NODE_SCALAR_INTERP = 22;
  public static readonly int NODE_VEC_INTERP = 23;
  public static readonly int NODE_COLOR_RAMP = 24;
  public static readonly int NODE_CURVE_MAP = 25;
  public static readonly int NODE_SCALAR_INPUT = 26;
  public static readonly int NODE_VEC_INPUT = 27;
  public static readonly int NODE_RGB_INPUT = 28;
  public static readonly int NODE_XFORM_INPUT = 29;
  public static readonly int NODE_TEXTURE_INPUT = 30;
  public static readonly int NODE_CUBEMAP_INPUT = 31;
  public static readonly int NODE_DEFAULT_TEXTURE = 32;
  public static readonly int NODE_OUTPUT = 33;
  public static readonly int NODE_COMMENT = 34;
  public static readonly int NODE_TYPE_MAX = 35;
  public static readonly int SLOT_TYPE_SCALAR = 0;
  public static readonly int SLOT_TYPE_VEC = 1;
  public static readonly int SLOT_TYPE_XFORM = 2;
  public static readonly int SLOT_TYPE_TEXTURE = 3;
  public static readonly int SLOT_MAX = 4;
  public static readonly int SHADER_TYPE_VERTEX = 0;
  public static readonly int SHADER_TYPE_FRAGMENT = 1;
  public static readonly int SHADER_TYPE_LIGHT = 2;
  public static readonly int SHADER_TYPE_MAX = 3;
  public static readonly int SLOT_IN = 0;
  public static readonly int SLOT_OUT = 1;
  public static readonly int GRAPH_OK = 0;
  public static readonly int GRAPH_ERROR_CYCLIC = 1;
  public static readonly int GRAPH_ERROR_MISSING_CONNECTIONS = 2;
  public static readonly int SCALAR_OP_ADD = 0;
  public static readonly int SCALAR_OP_SUB = 1;
  public static readonly int SCALAR_OP_MUL = 2;
  public static readonly int SCALAR_OP_DIV = 3;
  public static readonly int SCALAR_OP_MOD = 4;
  public static readonly int SCALAR_OP_POW = 5;
  public static readonly int SCALAR_OP_MAX = 6;
  public static readonly int SCALAR_OP_MIN = 7;
  public static readonly int SCALAR_OP_ATAN2 = 8;
  public static readonly int SCALAR_MAX_OP = 9;
  public static readonly int VEC_OP_ADD = 0;
  public static readonly int VEC_OP_SUB = 1;
  public static readonly int VEC_OP_MUL = 2;
  public static readonly int VEC_OP_DIV = 3;
  public static readonly int VEC_OP_MOD = 4;
  public static readonly int VEC_OP_POW = 5;
  public static readonly int VEC_OP_MAX = 6;
  public static readonly int VEC_OP_MIN = 7;
  public static readonly int VEC_OP_CROSS = 8;
  public static readonly int VEC_MAX_OP = 9;
  public static readonly int VEC_SCALAR_OP_MUL = 0;
  public static readonly int VEC_SCALAR_OP_DIV = 1;
  public static readonly int VEC_SCALAR_OP_POW = 2;
  public static readonly int VEC_SCALAR_MAX_OP = 3;
  public static readonly int RGB_OP_SCREEN = 0;
  public static readonly int RGB_OP_DIFFERENCE = 1;
  public static readonly int RGB_OP_DARKEN = 2;
  public static readonly int RGB_OP_LIGHTEN = 3;
  public static readonly int RGB_OP_OVERLAY = 4;
  public static readonly int RGB_OP_DODGE = 5;
  public static readonly int RGB_OP_BURN = 6;
  public static readonly int RGB_OP_SOFT_LIGHT = 7;
  public static readonly int RGB_OP_HARD_LIGHT = 8;
  public static readonly int RGB_MAX_OP = 9;
  public static readonly int SCALAR_FUNC_SIN = 0;
  public static readonly int SCALAR_FUNC_COS = 1;
  public static readonly int SCALAR_FUNC_TAN = 2;
  public static readonly int SCALAR_FUNC_ASIN = 3;
  public static readonly int SCALAR_FUNC_ACOS = 4;
  public static readonly int SCALAR_FUNC_ATAN = 5;
  public static readonly int SCALAR_FUNC_SINH = 6;
  public static readonly int SCALAR_FUNC_COSH = 7;
  public static readonly int SCALAR_FUNC_TANH = 8;
  public static readonly int SCALAR_FUNC_LOG = 9;
  public static readonly int SCALAR_FUNC_EXP = 10;
  public static readonly int SCALAR_FUNC_SQRT = 11;
  public static readonly int SCALAR_FUNC_ABS = 12;
  public static readonly int SCALAR_FUNC_SIGN = 13;
  public static readonly int SCALAR_FUNC_FLOOR = 14;
  public static readonly int SCALAR_FUNC_ROUND = 15;
  public static readonly int SCALAR_FUNC_CEIL = 16;
  public static readonly int SCALAR_FUNC_FRAC = 17;
  public static readonly int SCALAR_FUNC_SATURATE = 18;
  public static readonly int SCALAR_FUNC_NEGATE = 19;
  public static readonly int SCALAR_MAX_FUNC = 20;
  public static readonly int VEC_FUNC_NORMALIZE = 0;
  public static readonly int VEC_FUNC_SATURATE = 1;
  public static readonly int VEC_FUNC_NEGATE = 2;
  public static readonly int VEC_FUNC_RECIPROCAL = 3;
  public static readonly int VEC_FUNC_RGB2HSV = 4;
  public static readonly int VEC_FUNC_HSV2RGB = 5;
  public static readonly int VEC_MAX_FUNC = 6;

  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  
  internal ShaderGraph(global::System.IntPtr cPtr, bool cMemoryOwn) : base(GodotEnginePINVOKE.ShaderGraph_SWIGUpcast(cPtr), cMemoryOwn) {
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }  
  
  protected ShaderGraph(bool cMemoryOwn) : base(cMemoryOwn) {}
  
  new internal void internal_init(global::System.IntPtr cPtr) {
    base.internal_init(GodotEnginePINVOKE.ShaderGraph_SWIGUpcast(cPtr));
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }
  
  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(ShaderGraph obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  ~ShaderGraph() {
    Dispose();
  }

  public override void Dispose() {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          GodotEnginePINVOKE.delete_ShaderGraph(swigCPtr);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

  internal ShaderGraph() {}


  public void node_add(int shader_type, int node_type, int id) {
    GodotEnginePINVOKE.ShaderGraph_node_add(swigCPtr, shader_type, node_type, id);
  }

  public void node_remove(int shader_type, int id) {
    GodotEnginePINVOKE.ShaderGraph_node_remove(swigCPtr, shader_type, id);
  }

  public void node_set_pos(int shader_type, int id, Vector2 pos) {
    GodotEnginePINVOKE.ShaderGraph_node_set_pos(swigCPtr, shader_type, id, ref pos);
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public Vector2 node_get_pos(int shader_type, int id) {
    Vector2 ret = GodotEnginePINVOKE.ShaderGraph_node_get_pos(swigCPtr, shader_type, id);
    return ret;
}

  public int node_get_type(int shader_type, int id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_node_get_type(swigCPtr, shader_type, id);
    return ret;
  }

  public SWIGTYPE_p_Array get_node_list(int shader_type) {
    SWIGTYPE_p_Array ret = new SWIGTYPE_p_Array(GodotEnginePINVOKE.ShaderGraph_get_node_list(swigCPtr, shader_type), true);
    return ret;
  }

  public void default_set_value(int shader_type, int id, int param_id, Variant value) {
    GodotEnginePINVOKE.ShaderGraph_default_set_value(swigCPtr, shader_type, id, param_id, Variant.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public void default_get_value(int shader_type, int id, int param_id) {
    GodotEnginePINVOKE.ShaderGraph_default_get_value(swigCPtr, shader_type, id, param_id);
  }

  public void scalar_const_node_set_value(int shader_type, int id, float value) {
    GodotEnginePINVOKE.ShaderGraph_scalar_const_node_set_value(swigCPtr, shader_type, id, value);
  }

  public float scalar_const_node_get_value(int shader_type, int id) {
    float ret = GodotEnginePINVOKE.ShaderGraph_scalar_const_node_get_value(swigCPtr, shader_type, id);
    return ret;
  }

  public void vec_const_node_set_value(int shader_type, int id, SWIGTYPE_p_Vector3 value) {
    GodotEnginePINVOKE.ShaderGraph_vec_const_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Vector3.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Vector3 vec_const_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Vector3 ret = new SWIGTYPE_p_Vector3(GodotEnginePINVOKE.ShaderGraph_vec_const_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void rgb_const_node_set_value(int shader_type, int id, SWIGTYPE_p_Color value) {
    GodotEnginePINVOKE.ShaderGraph_rgb_const_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Color.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Color rgb_const_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Color ret = new SWIGTYPE_p_Color(GodotEnginePINVOKE.ShaderGraph_rgb_const_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void xform_const_node_set_value(int shader_type, int id, SWIGTYPE_p_Transform value) {
    GodotEnginePINVOKE.ShaderGraph_xform_const_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Transform.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Transform xform_const_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Transform ret = new SWIGTYPE_p_Transform(GodotEnginePINVOKE.ShaderGraph_xform_const_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void texture_node_set_filter_size(int shader_type, int id, int filter_size) {
    GodotEnginePINVOKE.ShaderGraph_texture_node_set_filter_size(swigCPtr, shader_type, id, filter_size);
  }

  public int texture_node_get_filter_size(int shader_type, int id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_texture_node_get_filter_size(swigCPtr, shader_type, id);
    return ret;
  }

  public void texture_node_set_filter_strength(int shader_type, float id, float filter_strength) {
    GodotEnginePINVOKE.ShaderGraph_texture_node_set_filter_strength(swigCPtr, shader_type, id, filter_strength);
  }

  public float texture_node_get_filter_strength(int shader_type, float id) {
    float ret = GodotEnginePINVOKE.ShaderGraph_texture_node_get_filter_strength(swigCPtr, shader_type, id);
    return ret;
  }

  public void scalar_op_node_set_op(int shader_type, float id, int op) {
    GodotEnginePINVOKE.ShaderGraph_scalar_op_node_set_op(swigCPtr, shader_type, id, op);
  }

  public int scalar_op_node_get_op(int shader_type, float id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_scalar_op_node_get_op(swigCPtr, shader_type, id);
    return ret;
  }

  public void vec_op_node_set_op(int shader_type, float id, int op) {
    GodotEnginePINVOKE.ShaderGraph_vec_op_node_set_op(swigCPtr, shader_type, id, op);
  }

  public int vec_op_node_get_op(int shader_type, float id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_vec_op_node_get_op(swigCPtr, shader_type, id);
    return ret;
  }

  public void vec_scalar_op_node_set_op(int shader_type, float id, int op) {
    GodotEnginePINVOKE.ShaderGraph_vec_scalar_op_node_set_op(swigCPtr, shader_type, id, op);
  }

  public int vec_scalar_op_node_get_op(int shader_type, float id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_vec_scalar_op_node_get_op(swigCPtr, shader_type, id);
    return ret;
  }

  public void rgb_op_node_set_op(int shader_type, float id, int op) {
    GodotEnginePINVOKE.ShaderGraph_rgb_op_node_set_op(swigCPtr, shader_type, id, op);
  }

  public int rgb_op_node_get_op(int shader_type, float id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_rgb_op_node_get_op(swigCPtr, shader_type, id);
    return ret;
  }

  public void xform_vec_mult_node_set_no_translation(int shader_type, int id, bool disable) {
    GodotEnginePINVOKE.ShaderGraph_xform_vec_mult_node_set_no_translation(swigCPtr, shader_type, id, disable);
  }

  public bool xform_vec_mult_node_get_no_translation(int shader_type, int id) {
    bool ret = GodotEnginePINVOKE.ShaderGraph_xform_vec_mult_node_get_no_translation(swigCPtr, shader_type, id);
    return ret;
  }

  public void scalar_func_node_set_function(int shader_type, int id, int func) {
    GodotEnginePINVOKE.ShaderGraph_scalar_func_node_set_function(swigCPtr, shader_type, id, func);
  }

  public int scalar_func_node_get_function(int shader_type, int id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_scalar_func_node_get_function(swigCPtr, shader_type, id);
    return ret;
  }

  public void vec_func_node_set_function(int shader_type, int id, int func) {
    GodotEnginePINVOKE.ShaderGraph_vec_func_node_set_function(swigCPtr, shader_type, id, func);
  }

  public int vec_func_node_get_function(int shader_type, int id) {
    int ret = GodotEnginePINVOKE.ShaderGraph_vec_func_node_get_function(swigCPtr, shader_type, id);
    return ret;
  }

  public void input_node_set_name(int shader_type, int id, string name) {
    GodotEnginePINVOKE.ShaderGraph_input_node_set_name(swigCPtr, shader_type, id, name);
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public string input_node_get_name(int shader_type, int id) {
    string ret = GodotEnginePINVOKE.ShaderGraph_input_node_get_name(swigCPtr, shader_type, id);
    return ret;
  }

  public void scalar_input_node_set_value(int shader_type, int id, float value) {
    GodotEnginePINVOKE.ShaderGraph_scalar_input_node_set_value(swigCPtr, shader_type, id, value);
  }

  public float scalar_input_node_get_value(int shader_type, int id) {
    float ret = GodotEnginePINVOKE.ShaderGraph_scalar_input_node_get_value(swigCPtr, shader_type, id);
    return ret;
  }

  public void vec_input_node_set_value(int shader_type, int id, SWIGTYPE_p_Vector3 value) {
    GodotEnginePINVOKE.ShaderGraph_vec_input_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Vector3.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Vector3 vec_input_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Vector3 ret = new SWIGTYPE_p_Vector3(GodotEnginePINVOKE.ShaderGraph_vec_input_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void rgb_input_node_set_value(int shader_type, int id, SWIGTYPE_p_Color value) {
    GodotEnginePINVOKE.ShaderGraph_rgb_input_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Color.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Color rgb_input_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Color ret = new SWIGTYPE_p_Color(GodotEnginePINVOKE.ShaderGraph_rgb_input_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void xform_input_node_set_value(int shader_type, int id, SWIGTYPE_p_Transform value) {
    GodotEnginePINVOKE.ShaderGraph_xform_input_node_set_value(swigCPtr, shader_type, id, SWIGTYPE_p_Transform.getCPtr(value));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Transform xform_input_node_get_value(int shader_type, int id) {
    SWIGTYPE_p_Transform ret = new SWIGTYPE_p_Transform(GodotEnginePINVOKE.ShaderGraph_xform_input_node_get_value(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void texture_input_node_set_value(int shader_type, int id, Texture value) {
    GodotEnginePINVOKE.ShaderGraph_texture_input_node_set_value(swigCPtr, shader_type, id, Texture.getCPtr(value));
  }

  public Texture texture_input_node_get_value(int shader_type, int id) {
    global::System.IntPtr cPtr = GodotEnginePINVOKE.ShaderGraph_texture_input_node_get_value(swigCPtr, shader_type, id);
    if (cPtr == global::System.IntPtr.Zero)
      return null;
    Texture ret = InternalHelpers.UnmanagedGetManaged(cPtr) as Texture;
    return ret;
}

  public void cubemap_input_node_set_value(int shader_type, int id, CubeMap value) {
    GodotEnginePINVOKE.ShaderGraph_cubemap_input_node_set_value(swigCPtr, shader_type, id, CubeMap.getCPtr(value));
  }

  public CubeMap cubemap_input_node_get_value(int shader_type, int id) {
    global::System.IntPtr cPtr = GodotEnginePINVOKE.ShaderGraph_cubemap_input_node_get_value(swigCPtr, shader_type, id);
    if (cPtr == global::System.IntPtr.Zero)
      return null;
    CubeMap ret = InternalHelpers.UnmanagedGetManaged(cPtr) as CubeMap;
    return ret;
}

  public void comment_node_set_text(int shader_type, int id, string text) {
    GodotEnginePINVOKE.ShaderGraph_comment_node_set_text(swigCPtr, shader_type, id, text);
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public string comment_node_get_text(int shader_type, int id) {
    string ret = GodotEnginePINVOKE.ShaderGraph_comment_node_get_text(swigCPtr, shader_type, id);
    return ret;
  }

  public void color_ramp_node_set_ramp(int shader_type, int id, SWIGTYPE_p_ColorArray colors, SWIGTYPE_p_RealArray offsets) {
    GodotEnginePINVOKE.ShaderGraph_color_ramp_node_set_ramp(swigCPtr, shader_type, id, SWIGTYPE_p_ColorArray.getCPtr(colors), SWIGTYPE_p_RealArray.getCPtr(offsets));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_ColorArray color_ramp_node_get_colors(int shader_type, int id) {
    SWIGTYPE_p_ColorArray ret = new SWIGTYPE_p_ColorArray(GodotEnginePINVOKE.ShaderGraph_color_ramp_node_get_colors(swigCPtr, shader_type, id), true);
    return ret;
  }

  public SWIGTYPE_p_RealArray color_ramp_node_get_offsets(int shader_type, int id) {
    SWIGTYPE_p_RealArray ret = new SWIGTYPE_p_RealArray(GodotEnginePINVOKE.ShaderGraph_color_ramp_node_get_offsets(swigCPtr, shader_type, id), true);
    return ret;
  }

  public void curve_map_node_set_points(int shader_type, int id, SWIGTYPE_p_Vector2Array points) {
    GodotEnginePINVOKE.ShaderGraph_curve_map_node_set_points(swigCPtr, shader_type, id, SWIGTYPE_p_Vector2Array.getCPtr(points));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public SWIGTYPE_p_Vector2Array curve_map_node_get_points(int shader_type, int id) {
    SWIGTYPE_p_Vector2Array ret = new SWIGTYPE_p_Vector2Array(GodotEnginePINVOKE.ShaderGraph_curve_map_node_get_points(swigCPtr, shader_type, id), true);
    return ret;
  }

  public int connect_node(int shader_type, int src_id, int src_slot, int dst_id, int dst_slot) {
    int ret = GodotEnginePINVOKE.ShaderGraph_connect_node(swigCPtr, shader_type, src_id, src_slot, dst_id, dst_slot);
    return ret;
  }

  public bool is_node_connected(int shader_type, int src_id, int src_slot, int dst_id, int dst_slot) {
    bool ret = GodotEnginePINVOKE.ShaderGraph_is_node_connected(swigCPtr, shader_type, src_id, src_slot, dst_id, dst_slot);
    return ret;
  }

  public void disconnect_node(int shader_type, int src_id, int src_slot, int dst_id, int dst_slot) {
    GodotEnginePINVOKE.ShaderGraph_disconnect_node(swigCPtr, shader_type, src_id, src_slot, dst_id, dst_slot);
  }

  public SWIGTYPE_p_Array get_node_connections(int shader_type) {
    SWIGTYPE_p_Array ret = new SWIGTYPE_p_Array(GodotEnginePINVOKE.ShaderGraph_get_node_connections(swigCPtr, shader_type), true);
    return ret;
  }

  public void clear(int shader_type) {
    GodotEnginePINVOKE.ShaderGraph_clear(swigCPtr, shader_type);
  }

  public void node_set_state(int shader_type, int id, Variant state) {
    GodotEnginePINVOKE.ShaderGraph_node_set_state(swigCPtr, shader_type, id, Variant.getCPtr(state));
    if (GodotEnginePINVOKE.SWIGPendingException.Pending) throw GodotEnginePINVOKE.SWIGPendingException.Retrieve();
  }

  public Variant node_get_state(int shader_type, int id) {
    Variant ret = new Variant(GodotEnginePINVOKE.ShaderGraph_node_get_state(swigCPtr, shader_type, id), true);
    return ret;
  }

}

}
